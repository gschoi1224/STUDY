# 효율적인 화폐 구성

# N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다.
# 이때 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다.
# 예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수이다.
# 입력 조건
# - 첫째 줄에 N, M이 주어진다. (1 <= N <= 100, 1 <= M <= 10,000)
# - 이후 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐 가치는 10,000보다 작거나 같은 자연수이다.
# 출력 조건
# - 첫째 줄에 M원을 만들기 위한 최소한의 화폐 개수를 출력한다.
# - 불가능할 때는 -1을 출력한다.
# 입력 예시 1
# 2 15
# 2
# 3
# 출력 예시 1
# 5
# 입력 예시 2
# 3 4
# 3
# 5
# 7
# 출력 예시 2
# -1

n, m = map(int, input().split())
array = []
for _ in range(n) :
    array.append(int(input()))
d = [-1] * (m + 1)

for i in range(min(array), m + 1) :
    if i in array :
        d[i] = 1
        continue
    for num in array :
        if d[i - num] != -1 :
            if (d[i] == -1) : d[i] = d[i - num] + 1
            else : d[i] = min(d[i], d[i - num] + 1)
            
print(d[m])

# 문제 풀이
# 이 문제는 작은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 최소한의 화폐 개수를 찾으면 된다. 금액 i를 만들 수 있는 최소한의 화폐 개수를 a(i),
# 화폐의 단위를 a(k)라고 했을 때, 다음과 같은 점화식을 작성할 수 있다. a(i-k)는 금액 (i-k)를 만들 수 있는 최소한의 화폐 금액을 의미한다.
# - a(i-k)를 만드는 방법이 존재하는 경우 a(i) = min(a(i), a(i-k) + 1)
# - a(i-k)를 만드는 방법이 존재하지 않는 경우 a(i) = 10,001
# 이 점화식을 모든 화폐 단위에 대하여 차례대로 적용하면 된다. 실제로 문제를 풀기 위해서는 가장 먼저 K의 크기만큼 리스트를 할당한다.
# 이후에 각 인덱스를 '금액'으로 고려하여 메모이제이션을 진행한다.

# 답안 예시
n, m = map(int, input().split())
array = []
for i in range(n) :
    array.append(int(input()))

# 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (m + 1)

# 다이나믹 프로그래밍 진행(보텀업)
d[0] = 0
for i in range(n) :
    for j in range(array[i], m + 1) :
        if d[j - array[j]] != 10001 : # (i - k)원을 만드는 방법이 존재하는 경우
            d[j] = min(d[j], d[j - array[i]] + 1)

# 계산된 결과 출력
if d[m] == 10001 : # 최종적으로 M원을 만드는 방법이 없는 경우
    print(-1)
else :
    print(d[m])